# AlphaPulse UI Architecture & Workflows

## Core Philosophy
AlphaPulse enables progressive complexity disclosure in quantitative trading - users start with button-driven workflows and gradually transition to code-based power users, all within the same platform.

## Page Architecture

### 1. Home Page (News Feed)
**Purpose**: Market awareness and community engagement
- **Data Flow**: 
  - News API → Backend aggregator → Frontend feed
  - User comments → PostgreSQL → Real-time updates via WebSocket
- **Key Features**:
  - Market summary widget with key indices

### 2. Research Page (Strategy Discovery & Development)
**Purpose**: Core value proposition - progressive learning environment
- **Workflow Layers**:
  1. **Discovery Layer**: Grid of strategy cards with performance metrics
  2. **Button-UI Layer**: No-code strategy analysis via pre-built components
  3. **Notebook Layer**: Full Jupyter environment for power users
  4. **Data Layer**: SQL-based data exploration and dataset creation

- **Data Flow**:
  ```
  User Action → Manifest Generation → Cache Check → Compute/Retrieve → Display
  ```
  
- **Manifest Structure** (proposed):
  ```typescript
  interface AnalysisManifest {
    symbol: string | string[];
    timeframe: '1m' | '5m' | '15m' | '1h' | '1d';
    dateRange: { start: Date; end: Date };
    strategy: {
      type: string;
      version: string;
      parameters: Record<string, any>;
    };
    indicators: string[];
    features: string[];
    hash: string; // SHA256 of above for cache key
  }
  ```

- **Caching Strategy**:
  - Signal cache: Pre-computed indicator values (RSI, MACD, etc.)
  - Feature cache: Derived features (rolling stats, patterns)
  - Backtest cache: Full backtest results for parameter combinations
  - TTL: Based on timeframe (1m=1hr, 1d=24hr)

### 3. Develop Page (Power User Environment)
**Purpose**: Full IDE for strategy development and system customization
- **Components**:
  - Monaco editor with Python/TypeScript support
  - File explorer with Git integration
  - Terminal emulator
  - Backtest runner with real-time progress
  - Test suite runner
  
- **API Endpoints**:
  ```
  POST /api/strategies/compile - Validate strategy code
  POST /api/strategies/backtest - Run backtest with manifest
  GET  /api/strategies/results/{id} - Stream backtest results
  POST /api/templates/button-ui - Save custom button-UI
  POST /api/templates/notebook - Save notebook template
  ```

### 4. Monitor Page (Live Trading & Debugging)
**Purpose**: Real-time strategy execution monitoring and debugging
- **Features**:
  - Bar-by-bar replay with event stream
  - Live position tracking
  - Strategy state inspection
  - Performance metrics dashboard
  
- **Data Flow**:
  - NautilusTrader → Event Bus → WebSocket → Frontend
  - Events stored in TimescaleDB for replay
  
## Backend Integration

### NautilusTrader Event-Driven Architecture
```python
# Proposed backend structure
class AlphaPulseEngine:
    def __init__(self):
        self.trader = NautilusTrader()
        self.signal_cache = SignalCache(redis_client)
        self.feature_store = FeatureStore(postgres_client)
        self.backtest_cache = BacktestCache(s3_client)
    
    async def process_manifest(self, manifest: AnalysisManifest):
        cache_key = manifest.hash
        
        # Check cache layers
        if result := await self.backtest_cache.get(cache_key):
            return result
            
        # Compute signals/features
        signals = await self.compute_signals(manifest)
        features = await self.compute_features(manifest, signals)
        
        # Run strategy
        result = await self.trader.run_backtest(
            strategy=manifest.strategy,
            data=features
        )
        
        # Cache results
        await self.backtest_cache.set(cache_key, result)
        return result
```

### API Structure
```typescript
// Frontend service layer
class AlphaPulseAPI {
  async runAnalysis(manifest: AnalysisManifest): Promise<BacktestResult> {
    // Check local IndexedDB cache first
    const cached = await localCache.get(manifest.hash);
    if (cached && !isStale(cached)) return cached;
    
    // Request from backend
    const result = await fetch('/api/analysis/run', {
      method: 'POST',
      body: JSON.stringify(manifest)
    });
    
    // Cache locally
    await localCache.set(manifest.hash, result);
    return result;
  }
}
```

## Data Persistence Layers

1. **Hot Cache** (Redis): Active signals, live prices, recent manifests
2. **Warm Storage** (PostgreSQL): User strategies, backtest results, features
3. **Cold Storage** (S3): Historical backtests, large datasets
4. **Local Cache** (IndexedDB): User's recent analyses, chart data

## Progressive User Journey

```mermaid
graph LR
    A[Strategy Card] --> B[Button-UI]
    B --> C[Inspect Cell]
    C --> D[Modify Code]
    D --> E[Create Template]
    E --> F[Share Community]
    
    B --> G[AI Assistant]
    G --> C
    
    style A fill:#e1f5e1
    style B fill:#ffe1e1
    style E fill:#e1e1ff
```

## Performance Optimizations

1. **Manifest Deduplication**: Hash similar requests, serve from cache
2. **Incremental Computation**: Only compute new data points
3. **Lazy Loading**: Stream results as computed
4. **WebWorker Processing**: Heavy computations off main thread
5. **Virtual Scrolling**: Handle large datasets in UI

## Security Considerations

- Strategy code sandboxing via Docker containers
- Rate limiting on backtest requests
- User quotas based on subscription tier
- Isolated execution environments per user