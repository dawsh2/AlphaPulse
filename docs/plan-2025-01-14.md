# AlphaPulse Development Plan
**Date: 2025-01-14**
**Author: System Architecture Team**
**Status: Active Development**

## Executive Summary

AlphaPulse is a high-performance quantitative trading framework handling real-time market data with microsecond-level latency. The system successfully streams L2 orderbook data from multiple exchanges through an optimized Unix socket pipeline achieving ~35Î¼s end-to-end latency.

## System Architecture Overview

```
Exchange APIs â†’ Exchange Collector â†’ Unix Socket â†’ Relay Server â†’ Unix Socket â†’ WS Bridge â†’ WebSocket â†’ Frontend
     (WebSocket)        (Rust)           â†“            (Rust)          â†“         (Rust)        â†“        (React)
                                    /tmp/sockets                  /tmp/relay                ws://8765    :5174
```

## Completed Work (as of 2025-01-13)

### âœ… Critical Bug Fixes
1. **L2 Orderbook Streaming Issue**
   - **Problem**: WriterThread bottleneck limiting message processing to 100 messages per iteration
   - **Solution**: Removed artificial limit, eliminated unnecessary sleeps
   - **Impact**: Full orderbook depth now streaming correctly

2. **Symbol Format Mismatch**
   - **Problem**: Frontend expected "BTC-USD", backend sent "BTC/USD"
   - **Solution**: Standardized format across ws_bridge service
   - **Files Modified**: `backend/services/ws_bridge/src/main.rs:234-237, 379-382`

3. **Orderbook Data Structure**
   - **Problem**: Frontend expected `{price, size}` objects, received arrays
   - **Solution**: Updated ws_bridge to format messages correctly
   - **Impact**: Dashboard now displays live orderbook data

### âœ… UI/UX Enhancements
- Auto-centering orderbook display on spread
- Visual spread indicator with gradient background
- Smooth scrolling behavior
- Limited display to 20 levels for clarity

### âœ… Current Performance Metrics
- **Latency**: ~35 microseconds end-to-end
- **Throughput**: >100,000 messages/second per exchange
- **Active Exchanges**: Kraken (ID: 1), Coinbase (ID: 2)
- **Active Symbols**: BTC-USD, ETH-USD

## Today's Development Plan (2025-01-14)
**Updated**: Market hours priority - Alpaca collector before close

### ðŸŽ¯ URGENT Priority 1: Alpaca Stock Market Collector (Before 4 PM EST)
**Goal**: Capture stock market data from Alpaca before markets close

#### Implementation Details
```rust
// New module: backend/services/exchange_collector/src/exchanges/alpaca.rs
struct AlpacaCollector {
    api_key: String,
    api_secret: String,
    ws_client: WebSocketClient,
    symbol_mapper: Arc<RwLock<SymbolMapper>>,
}
```

#### Tasks:
- [ ] Create Alpaca WebSocket collector module
- [ ] Implement authentication (API key/secret)
- [ ] Subscribe to real-time stock quotes and trades
- [ ] Support popular stocks: AAPL, MSFT, GOOGL, AMZN, TSLA, SPY, QQQ
- [ ] Convert to internal binary protocol
- [ ] Test with live market data before close

#### Alpaca WebSocket Format:
```json
{
  "stream": "wss://stream.data.alpaca.markets/v2/iex",
  "auth": {"action": "auth", "key": "API_KEY", "secret": "API_SECRET"},
  "subscribe": {
    "action": "subscribe", 
    "trades": ["AAPL", "MSFT", "TSLA"],
    "quotes": ["AAPL", "MSFT", "TSLA"],
    "bars": ["AAPL", "MSFT", "TSLA"]
  }
}
```

### ðŸŽ¯ Priority 2: Data Persistence Layer (After Market Close)
**Goal**: Capture all streaming data to disk for analysis and replay

#### Implementation Details
```rust
// New service: backend/services/data_writer/
struct DataWriter {
    trades_writer: ParquetWriter<Trade>,
    orderbook_writer: ParquetWriter<L2Update>,
    rotation_interval: Duration, // 1 hour default
    base_path: PathBuf,         // /Users/daws/alphapulse/data/parquet/
}
```

#### Tasks:
- [ ] Create new Rust service `data_writer`
- [ ] Implement Parquet schema for trades and orderbook
- [ ] Add Unix socket reader from relay server
- [ ] Implement hourly file rotation
- [ ] Add compression (Snappy or LZ4)
- [ ] Create data retention policy
- [ ] Add in-memory buffer for service interruptions
- [ ] Implement write-ahead log for data durability
- [ ] Support hot configuration reload without restart

#### File Structure:
```
data/parquet/
â”œâ”€â”€ trades/
â”‚   â”œâ”€â”€ 2025-01-14/
â”‚   â”‚   â”œâ”€â”€ trades_00.parquet
â”‚   â”‚   â”œâ”€â”€ trades_01.parquet
â”‚   â”‚   â””â”€â”€ ...
â””â”€â”€ orderbook/
    â”œâ”€â”€ 2025-01-14/
    â”‚   â”œâ”€â”€ orderbook_00.parquet
    â”‚   â”œâ”€â”€ orderbook_01.parquet
    â”‚   â””â”€â”€ ...
```

### ðŸŽ¯ Priority 2: Configuration System
**Goal**: Eliminate hardcoded values, enable dynamic configuration

#### Configuration Files to Create:
```toml
# config/exchanges.toml
[exchanges.kraken]
id = 1
name = "Kraken"
ws_endpoint = "wss://ws.kraken.com"
symbols = ["BTC-USD", "ETH-USD", "SOL-USD"]
enabled = true

[exchanges.coinbase]
id = 2
name = "Coinbase"
ws_endpoint = "wss://ws-feed.exchange.coinbase.com"
symbols = ["BTC-USD", "ETH-USD", "SOL-USD"]
enabled = true

[exchanges.binance]
id = 3
name = "Binance"
ws_endpoint = "wss://stream.binance.com:9443"
symbols = ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
enabled = false
```

```toml
# config/services.toml
[relay_server]
socket_path = "/tmp/relay"
buffer_size = 65536
max_connections = 100

[ws_bridge]
websocket_port = 8765
relay_socket = "/tmp/relay"
max_clients = 50

[data_writer]
relay_socket = "/tmp/relay"
base_path = "./data/parquet"
rotation_interval_hours = 1
compression = "snappy"
```

#### Implementation:
- [ ] Create `config` module in protocol crate
- [ ] Add TOML parsing with serde
- [ ] Update all services to use config
- [ ] Add config hot-reload capability
- [ ] Environment variable overrides

### ðŸŽ¯ Priority 3: Asset/Exchange Standardization
**Goal**: Dynamic symbol management without code changes

#### Current Issues:
- Hardcoded symbols in ws_bridge (lines 234-237, 379-382)
- Magic numbers for exchange IDs
- No central symbol registry
- Manual symbol addition requires code changes

#### Solution Architecture:
```rust
// protocol/src/config.rs
pub struct ExchangeRegistry {
    exchanges: HashMap<u16, ExchangeConfig>,
    symbols: HashMap<String, SymbolConfig>,
}

pub struct SymbolConfig {
    symbol: String,
    exchange_id: u16,
    base_asset: String,
    quote_asset: String,
    tick_size: f64,
    lot_size: f64,
}
```

#### Tasks:
- [ ] Create ExchangeRegistry in protocol crate
- [ ] Update ws_bridge to use registry
- [ ] Add symbol subscription API
- [ ] Implement symbol hot-reload
- [ ] Add validation for new symbols

### ðŸŽ¯ Priority 4: Code Quality
**Goal**: Clean up warnings and improve maintainability

#### Identified Issues:
- Unused imports in ws_bridge (Context, DashMap, gauge, Duration)
- Missing error types (using strings)
- No graceful shutdown handlers
- Incomplete logging coverage

#### Tasks:
- [ ] Remove all unused imports
- [ ] Create proper error types
- [ ] Add shutdown signal handlers
- [ ] Improve logging with tracing
- [ ] Add health check endpoints

## Development Schedule

### Day 1 (Today - 2025-01-14)
- **Morning**: Create data_writer service with basic Parquet writing
- **Afternoon**: Implement configuration system
- **Evening**: Test data persistence with live stream

### Day 2 (2025-01-15)
- **Morning**: Complete asset/exchange standardization
- **Afternoon**: Add monitoring and metrics
- **Evening**: Performance testing and optimization

### Day 3 (2025-01-16)
- **Morning**: Code cleanup and documentation
- **Afternoon**: Integration testing
- **Evening**: Deployment preparation

## Success Metrics

### Technical Metrics
- [ ] Zero message loss during 24-hour test
- [ ] Maintain <50Î¼s latency under load
- [ ] Successful hourly file rotation
- [ ] Clean compilation (no warnings)

### Functional Metrics
- [ ] Add new exchange in <5 minutes
- [ ] Add new symbol without restart
- [ ] Query historical data via DuckDB
- [ ] Dashboard displays all configured symbols

## Risk Mitigation

### Identified Risks
1. **Disk I/O Impact**: Parquet writing might affect latency
   - **Mitigation**: Separate thread with bounded queue
   
2. **File Size Growth**: Uncompressed data could fill disk
   - **Mitigation**: Snappy compression, retention policy
   
3. **Configuration Errors**: Invalid config could crash services
   - **Mitigation**: Schema validation, safe defaults

## Long-term Roadmap

### Q1 2025
- âœ… Real-time data streaming
- â³ Data persistence layer
- â³ Configuration management
- [ ] NautilusTrader integration
- [ ] Basic trading strategies

### Q2 2025
- [ ] Advanced analytics dashboard
- [ ] Machine learning pipeline
- [ ] Multi-exchange arbitrage
- [ ] Risk management system

### Q3 2025
- [ ] Cloud deployment
- [ ] Multi-region support
- [ ] Institutional features
- [ ] Compliance reporting

## Notes and Observations

### Performance Insights
- Unix sockets provide consistent <10Î¼s IPC latency
- Binary protocol reduces message size by ~70% vs JSON
- Tokio async runtime handles 1M+ msg/sec

### Architecture Decisions
- Separate services for fault isolation
- Binary protocol for internal communication
- Parquet for analytical workloads
- TimescaleDB for time-series queries

### Lessons Learned
- Message batching can create artificial bottlenecks
- Symbol format consistency is critical
- Frontend-backend contract must be explicit
- Real-time systems need observable metrics

## Contact and Resources

- **Repository**: /Users/daws/alphapulse
- **Dashboard**: http://localhost:5174
- **WebSocket**: ws://localhost:8765
- **Documentation**: ./docs/

---
*This document is updated daily during active development*