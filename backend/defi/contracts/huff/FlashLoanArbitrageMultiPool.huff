/// @title FlashLoanArbitrageMultiPool - True general-purpose multi-pool arbitrage
/// @notice Handles any combination of DEXs, tokens, and pool types
/// @dev Dynamic path encoding, V2/V3 support, multiple hops

// Interface definitions
#define function executeArbitrage(uint256,uint8,bytes) nonpayable returns ()
#define function executeOperation(address,uint256,uint256,address,bytes) nonpayable returns (bool)
#define function withdraw(address) nonpayable returns ()

// Constants
#define constant AAVE_POOL = 0x794a61358D6845594F94dc1DB02A252b5b4814aD
#define constant OWNER_SLOT = 0x00

// Pool type constants
#define constant POOL_V2 = 0x01
#define constant POOL_V3 = 0x02
#define constant POOL_CURVE = 0x03

// Function selectors
#define constant EXECUTE_OPERATION_SIG = 0x1b11d0ff
#define constant EXECUTE_ARBITRAGE_SIG = 0x3cd12659
#define constant WITHDRAW_SIG = 0x51cff8d9

// ERC20 selectors
#define constant APPROVE_SELECTOR = 0x095ea7b3
#define constant TRANSFER_SELECTOR = 0xa9059cbb
#define constant BALANCE_OF_SELECTOR = 0x70a08231

// DEX selectors
#define constant SWAP_EXACT_TOKENS_V2 = 0x38ed1739
#define constant SWAP_EXACT_INPUT_SINGLE_V3 = 0x414bf389
#define constant FLASH_LOAN_SELECTOR = 0x42b0b77c

/// @notice Main dispatcher
#define macro MAIN() = takes (0) returns (0) {
    0x00 calldataload 0xE0 shr
    
    dup1 [EXECUTE_OPERATION_SIG] eq executeOperation jumpi
    dup1 [EXECUTE_ARBITRAGE_SIG] eq executeArbitrage jumpi
    dup1 [WITHDRAW_SIG] eq withdraw jumpi

    0x00 0x00 revert

    executeOperation:
        EXECUTE_OPERATION_MULTIPOOL()
    executeArbitrage:
        EXECUTE_ARBITRAGE_MULTIPOOL()
    withdraw:
        WITHDRAW_TOKEN()
}

/// @notice Multi-pool arbitrage execution
#define macro EXECUTE_ARBITRAGE_MULTIPOOL() = takes (0) returns (0) {
    [OWNER_SLOT] sload caller xor owner_ok jumpi
    0x00 0x00 revert
    
    owner_ok:
    // Calldata structure:
    // 0x04: flashLoanAmount
    // 0x24: numSwaps (1-10)  
    // 0x44: swapData offset
    // swapData: [router][poolType][tokenIn][tokenOut][fee][minAmountOut] per swap
    
    0x04 calldataload   // flashLoanAmount
    0x24 calldataload   // numSwaps
    0x44 calldataload   // swapData offset (points to calldata location)
    
    // Build flash loan call
    [FLASH_LOAN_SELECTOR] 0x00 mstore
    address 0x04 mstore
    0x04 calldataload [USDC] mstore  // Assume USDC flash loan for now
    dup4 0x24 mstore               // amount
    0x80 0x44 mstore               // params offset
    0x00 0x64 mstore               // referralCode
    
    // Pack parameters for callback
    0x60 0x80 mstore               // params length
    dup3 0xa0 mstore               // numSwaps
    dup2 0xc0 mstore               // swapData offset
    dup1 0xe0 mstore               // minProfit (calculated off-chain)
    
    // Execute flash loan
    0x00 0x00 0x100 0x00 0x00 [AAVE_POOL] gas call
    pop pop pop pop
    stop
}

/// @notice Multi-pool flash loan callback
#define macro EXECUTE_OPERATION_MULTIPOOL() = takes (0) returns (0) {
    caller [AAVE_POOL] xor aave_ok jumpi
    0x00 0x00 revert
    
    aave_ok:
    0x24 calldataload   // amount
    0x44 calldataload   // premium
    0xa0 calldataload   // numSwaps
    0xc0 calldataload   // swapData offset
    0xe0 calldataload   // minProfit
    
    // Initialize loop variables
    dup3                // swapCounter = numSwaps
    dup3                // currentDataOffset = swapData offset
    dup5                // currentAmount = flash loan amount
    
    swap_loop:
        // Check if we have more swaps
        dup3 iszero end_swaps jumpi
        
        // Load swap instruction (6 parameters Ã— 32 bytes each)
        dup2 calldataload           // router
        dup3 0x20 add calldataload  // poolType
        dup4 0x40 add calldataload  // tokenIn
        dup5 0x60 add calldataload  // tokenOut
        dup6 0x80 add calldataload  // fee (for V3)
        dup7 0xa0 add calldataload  // minAmountOut
        
        // Execute swap based on pool type
        dup6 [POOL_V2] eq v2_swap jumpi
        dup6 [POOL_V3] eq v3_swap jumpi
        // Add more pool types as needed
        
        v2_swap:
            EXECUTE_V2_SWAP()
            jump swap_complete
            
        v3_swap:
            EXECUTE_V3_SWAP()
            jump swap_complete
            
        swap_complete:
        // Update loop variables
        dup4 0x01 sub       // decrement swapCounter
        dup3 0xc0 add       // advance dataOffset by 6*32 bytes
        // currentAmount is now on stack from swap result
        
        // Clean up swap parameters from stack
        swap7 pop pop pop pop pop pop pop
        
        jump swap_loop
    
    end_swaps:
    // Clean up loop variables
    pop pop pop
    
    // Calculate total debt and approve repayment
    dup6 dup6 add       // totalDebt = amount + premium
    APPROVE_TOKEN([USDC], [AAVE_POOL], dup1)
    
    // Transfer profit to owner
    TRANSFER_REMAINING_PROFIT()
    
    // Clean stack and return
    pop pop pop pop pop
    0x01 0x00 mstore
    0x20 0x00 return
}

/// @notice Execute Uniswap V2 style swap
#define macro EXECUTE_V2_SWAP() = takes (7) returns (1) {
    // Stack: [router, poolType, tokenIn, tokenOut, fee, minAmountOut, currentAmount]
    
    // Approve tokenIn to router
    dup5 dup8 dup1 APPROVE_TOKEN()
    
    // Build swapExactTokensForTokens call
    [SWAP_EXACT_TOKENS_V2] 0x00 mstore
    dup1 0x04 mstore                    // amountIn
    dup4 0x24 mstore                    // amountOutMin
    0x80 0x44 mstore                    // path offset
    address 0x64 mstore                 // to
    timestamp 0x012c add 0x84 mstore    // deadline
    
    // Build path array
    0x02 0x80 mstore                    // path length
    dup5 0xa0 mstore                    // tokenIn
    dup4 0xc0 mstore                    // tokenOut
    
    // Execute swap
    0x40 0x00 0xe0 0x00 0x00 dup8 gas call
    iszero swap_failed jumpi
    
    // Extract amount out (last element of returned array)
    0x20 mload      // Array starts at 0x00, last element offset
    0x01 sub        // Length - 1
    0x20 mul 0x20 add mload  // amounts[length-1]
    
    // Clean stack and return amount
    swap7 pop pop pop pop pop pop pop
    jump swap_success
    
    swap_failed:
        0x00 0x00 revert
        
    swap_success:
}

/// @notice Execute Uniswap V3 style swap
#define macro EXECUTE_V3_SWAP() = takes (7) returns (1) {
    // Stack: [router, poolType, tokenIn, tokenOut, fee, minAmountOut, currentAmount]
    
    // Approve tokenIn to router
    dup5 dup8 dup1 APPROVE_TOKEN()
    
    // Build exactInputSingle call
    [SWAP_EXACT_INPUT_SINGLE_V3] 0x00 mstore
    
    // Build ExactInputSingleParams struct
    dup5 0x04 mstore                    // tokenIn
    dup4 0x24 mstore                    // tokenOut
    dup3 0x44 mstore                    // fee
    address 0x64 mstore                 // recipient
    timestamp 0x012c add 0x84 mstore    // deadline
    dup1 0xa4 mstore                    // amountIn
    dup4 0xc4 mstore                    // amountOutMinimum
    0x00 0xe4 mstore                    // sqrtPriceLimitX96
    
    // Execute swap
    0x20 0x00 0x104 0x00 0x00 dup8 gas call
    iszero swap_failed_v3 jumpi
    
    0x00 mload      // amountOut
    
    // Clean stack and return amount
    swap7 pop pop pop pop pop pop pop
    jump swap_success_v3
    
    swap_failed_v3:
        0x00 0x00 revert
        
    swap_success_v3:
}

/// @notice Approve token spending
#define macro APPROVE_TOKEN() = takes (3) returns (0) {
    // Stack: [token, spender, amount]
    [APPROVE_SELECTOR] 0x00 mstore
    dup2 0x04 mstore
    dup1 0x24 mstore
    
    0x01 0x00 0x44 0x00 0x00 dup4 gas call
    iszero approve_failed jumpi
    
    pop pop pop
    jump approve_success
    
    approve_failed:
        0x00 0x00 revert
        
    approve_success:
}

/// @notice Transfer remaining profit to owner
#define macro TRANSFER_REMAINING_PROFIT() = takes (0) returns (0) {
    // Get current balance (assuming USDC for now)
    [BALANCE_OF_SELECTOR] 0x00 mstore
    address 0x04 mstore
    
    0x20 0x00 0x24 0x00 0x00 [USDC] gas staticcall
    iszero balance_failed jumpi
    
    0x00 mload      // current balance
    dup1 iszero no_profit jumpi
    
    // Transfer to owner
    [OWNER_SLOT] sload
    [TRANSFER_SELECTOR] 0x00 mstore
    dup2 0x04 mstore    // to
    dup2 0x24 mstore    // amount
    
    0x01 0x00 0x44 0x00 0x00 [USDC] gas call
    pop
    
    no_profit:
        pop
        jump profit_complete
        
    balance_failed:
        0x00 0x00 revert
        
    profit_complete:
}

/// @notice Withdraw tokens to owner
#define macro WITHDRAW_TOKEN() = takes (0) returns (0) {
    [OWNER_SLOT] sload caller xor withdraw_ok jumpi
    0x00 0x00 revert
    
    withdraw_ok:
    0x04 calldataload   // token
    
    // Get balance and transfer to owner
    dup1 address GET_TOKEN_BALANCE()
    dup1 iszero no_withdraw jumpi
    
    [OWNER_SLOT] sload
    dup3 dup2 dup3 TRANSFER_TOKEN()
    
    no_withdraw:
        pop pop
        stop
}

/// @notice Get token balance
#define macro GET_TOKEN_BALANCE() = takes (2) returns (1) {
    // Stack: [token, account]
    [BALANCE_OF_SELECTOR] 0x00 mstore
    dup1 0x04 mstore
    
    0x20 0x00 0x24 0x00 0x00 dup3 gas staticcall
    iszero balance_failed_2 jumpi
    
    0x00 mload
    swap2 pop pop
    jump balance_success_2
    
    balance_failed_2:
        0x00 0x00 revert
        
    balance_success_2:
}

/// @notice Transfer tokens
#define macro TRANSFER_TOKEN() = takes (3) returns (0) {
    // Stack: [token, to, amount]
    [TRANSFER_SELECTOR] 0x00 mstore
    dup2 0x04 mstore
    dup1 0x24 mstore
    
    0x01 0x00 0x44 0x00 0x00 dup4 gas call
    pop pop pop
}

/// @notice Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    caller [OWNER_SLOT] sstore
}