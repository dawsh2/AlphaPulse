/// @title FlashArbitrageBase - Direct Solidity to Huff Translation
/// @notice This contract is a byte-for-byte equivalent of FlashArbitrageOptimized.sol
/// @dev Phase 1 of Huff migration - prioritizes correctness over optimization

// Interface definitions
#define function executeArbitrage(uint256,uint256) nonpayable returns ()
#define function executeOperation(address[],uint256[],uint256[],address,bytes) nonpayable returns (bool)
#define function getExecutionStats() view returns (uint256,uint256,uint256,uint256)
#define function checkProfitability(uint256) view returns (uint256,uint256,uint256,uint256,bool)
#define function withdraw(address) nonpayable returns ()
#define function owner() view returns (address)

// Constants - Polygon addresses
#define constant ADDRESSES_PROVIDER = 0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb
#define constant POOL_ADDRESS = 0x794a61358D6845594F94dc1DB02A252b5b4814aD
#define constant WPOL = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270
#define constant USDC_OLD = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174
#define constant USDC_NEW = 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359
#define constant SUSHISWAP_ROUTER = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506
#define constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8

// Function selectors
#define constant APPROVE_SELECTOR = 0x095ea7b3
#define constant SWAP_EXACT_TOKENS_SELECTOR = 0x38ed1739
#define constant FLASHLOAN_SELECTOR = 0xab9c4b5d
#define constant TRANSFER_SELECTOR = 0xa9059cbb
#define constant BALANCE_OF_SELECTOR = 0x70a08231

// Storage slots
#define constant OWNER_SLOT = 0x00
#define constant LAST_GAS_USED_SLOT = 0x01
#define constant TOTAL_GAS_USED_SLOT = 0x02
#define constant EXECUTION_COUNT_SLOT = 0x03

// Main entry point
#define macro MAIN() = takes (0) returns (0) {
    0x00 calldataload 0xE0 shr          // [func_sig]
    
    dup1 __FUNC_SIG(executeArbitrage) eq execute_arbitrage jumpi
    dup1 __FUNC_SIG(executeOperation) eq execute_operation jumpi
    dup1 __FUNC_SIG(getExecutionStats) eq get_execution_stats jumpi
    dup1 __FUNC_SIG(checkProfitability) eq check_profitability jumpi
    dup1 __FUNC_SIG(withdraw) eq withdraw jumpi
    dup1 __FUNC_SIG(owner) eq get_owner jumpi
    
    // Invalid function selector
    0x00 0x00 revert
    
    execute_arbitrage:
        EXECUTE_ARBITRAGE()
    execute_operation:
        EXECUTE_OPERATION()
    get_execution_stats:
        GET_EXECUTION_STATS()
    check_profitability:
        CHECK_PROFITABILITY()
    withdraw:
        WITHDRAW()
    get_owner:
        GET_OWNER()
}

// Constructor - sets owner
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    caller [OWNER_SLOT] sstore
}

// Owner modifier equivalent
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller [OWNER_SLOT] sload eq is_owner jumpi
    
    // Revert with NotOwner()
    0x30cd747100000000000000000000000000000000000000000000000000000000
    0x00 mstore
    0x04 0x00 revert
    
    is_owner:
}

// Execute arbitrage - main function
#define macro EXECUTE_ARBITRAGE() = takes (0) returns (0) {
    ONLY_OWNER()
    
    // Get gas at start for tracking
    gas                                 // [gas_start]
    
    // Load parameters: executeArbitrage(uint256 flashAmount, uint256 minProfit)
    0x04 calldataload                   // [flashAmount, gas_start]
    0x24 calldataload                   // [minProfit, flashAmount, gas_start]
    
    // Execute flash loan
    EXECUTE_FLASH_LOAN()                // [gas_start]
    
    // Track gas usage
    gas                                 // [gas_end, gas_start]
    swap1 sub                           // [gas_used]
    
    // Update gas tracking storage
    UPDATE_GAS_STATS()
    
    // No return value needed
    stop
}

// Execute flash loan with exact Solidity replication
#define macro EXECUTE_FLASH_LOAN() = takes (2) returns (0) {
    // Stack: [minProfit, flashAmount]
    
    // Prepare flash loan calldata in memory
    0x40 mload                          // [ptr, minProfit, flashAmount]
    
    // Function selector: flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16)
    [FLASHLOAN_SELECTOR] dup2 mstore    // [ptr, minProfit, flashAmount]
    
    // receiverAddress = this
    address 0x04 dup3 add mstore        // [ptr, minProfit, flashAmount]
    
    // assets array offset
    0xe0 0x24 dup3 add mstore           // [ptr, minProfit, flashAmount]
    
    // amounts array offset  
    0x120 0x44 dup3 add mstore          // [ptr, minProfit, flashAmount]
    
    // modes array offset
    0x160 0x64 dup3 add mstore          // [ptr, minProfit, flashAmount]
    
    // onBehalfOf = this
    address 0x84 dup3 add mstore        // [ptr, minProfit, flashAmount]
    
    // params offset
    0x1a0 0xa4 dup3 add mstore          // [ptr, minProfit, flashAmount]
    
    // referralCode = 0
    0x00 0xc4 dup3 add mstore           // [ptr, minProfit, flashAmount]
    
    // Assets array: [USDC_OLD]
    0x01 0xe0 dup3 add mstore           // length = 1
    [USDC_OLD] 0x100 dup3 add mstore    // [ptr, minProfit, flashAmount]
    
    // Amounts array: [flashAmount]
    0x01 0x120 dup3 add mstore          // length = 1
    dup1 0x140 dup3 add mstore          // [ptr, minProfit, flashAmount]
    
    // Modes array: [0]
    0x01 0x160 dup3 add mstore          // length = 1
    0x00 0x180 dup3 add mstore          // [ptr, minProfit, flashAmount]
    
    // Params (encode minProfit)
    0x20 0x1a0 dup3 add mstore          // length of bytes
    swap1 0x1c0 dup3 add mstore         // [ptr, flashAmount]
    pop                                 // [ptr]
    
    // Update free memory pointer
    dup1 0x1e0 add 0x40 mstore          // [ptr]
    
    // Execute flash loan call
    0x00 0x00 0x1e0 dup4 0x00 [POOL_ADDRESS] gas call // [success, ptr]
    
    pop                                 // [success]
    success jumpi
    
    // Revert with FlashLoanFailed()
    0x7939f42400000000000000000000000000000000000000000000000000000000
    0x00 mstore
    0x04 0x00 revert
    
    success:
        // Clean up stack
        pop                             // []
}

// Flash loan callback - executeOperation
#define macro EXECUTE_OPERATION() = takes (0) returns (0) {
    // Verify caller is pool
    caller [POOL_ADDRESS] eq valid_caller jumpi
    0x00 0x00 revert
    
    valid_caller:
    
    // Verify initiator is this contract
    0x84 calldataload address eq valid_initiator jumpi
    0x00 0x00 revert
    
    valid_initiator:
    
    // Load amounts[0] and premiums[0]
    0x44 calldataload                   // [amounts_offset]
    0x20 add calldataload               // [amount_borrowed]
    
    0x64 calldataload                   // [premiums_offset, amount_borrowed]  
    0x20 add calldataload               // [premium, amount_borrowed]
    
    // Load minProfit from params
    0xa4 calldataload                   // [params_offset, premium, amount_borrowed]
    0x20 add calldataload               // [minProfit, premium, amount_borrowed]
    
    // Execute arbitrage logic
    dup3 EXECUTE_ARBITRAGE_LOGIC()      // [final_amount, minProfit, premium, amount_borrowed]
    
    // Calculate total debt
    dup3 dup3 add                       // [total_debt, final_amount, minProfit, premium, amount_borrowed]
    
    // Check profitability: final_amount >= total_debt + minProfit
    dup4 add                            // [required_amount, final_amount, minProfit, premium, amount_borrowed]
    dup2 dup2 lt insufficient_profit jumpi  // [required_amount, final_amount, ...]
    
    // Profit check passed, continue with repayment
    pop                                 // [final_amount, minProfit, premium, amount_borrowed]
    dup4 dup4 add                       // [total_debt, final_amount, minProfit, premium, amount_borrowed]
    
    // Approve repayment
    [USDC_OLD] [POOL_ADDRESS] dup3 APPROVE_TOKEN() // [total_debt, final_amount, ...]
    
    // Transfer profit to owner if any
    dup2 dup2 gt has_profit jumpi
    0x00 0x00 mstore
    0x20 0x00 return
    
    has_profit:
        sub                             // [profit, ...]
        [OWNER_SLOT] sload              // [owner, profit, ...]
        [USDC_OLD] dup3 dup3 TRANSFER_TOKEN() // [profit, ...]
        pop                             // [...]
        
        // Return true
        0x01 0x00 mstore
        0x20 0x00 return
    
    insufficient_profit:
        // Revert with InsufficientProfit()
        0x00 0x00 revert
}

// Execute arbitrage logic - USDC_OLD -> WPOL -> USDC_NEW
#define macro EXECUTE_ARBITRAGE_LOGIC() = takes (1) returns (1) {
    // Stack: [amount_in]
    
    // Step 1: Approve and swap USDC_OLD -> WPOL
    [USDC_OLD] [SUSHISWAP_ROUTER] dup3 APPROVE_TOKEN() // [amount_in]
    [USDC_OLD] [WPOL] dup2 [SUSHISWAP_ROUTER] EXECUTE_SWAP_EXACT() // [wpol_received]
    
    // Step 2: Approve and swap WPOL -> USDC_NEW
    [WPOL] [SUSHISWAP_ROUTER] dup2 APPROVE_TOKEN() // [wpol_received]
    [WPOL] [USDC_NEW] dup2 [SUSHISWAP_ROUTER] EXECUTE_SWAP_EXACT() // [final_amount]
}

// Token approval macro - exact Solidity replication
#define macro APPROVE_TOKEN() = takes (3) returns (0) {
    // Stack: [token, spender, amount]
    
    0x40 mload                          // [ptr, token, spender, amount]
    [APPROVE_SELECTOR] dup2 mstore      // [ptr, token, spender, amount]
    
    dup3 0x04 dup3 add mstore           // [ptr, token, spender, amount]
    dup1 0x24 dup3 add mstore           // [ptr, token, spender, amount]
    
    // Execute call
    0x00 0x00 0x44 dup4 0x00 dup7 gas call // [success, ptr, token, spender, amount]
    
    // Check success
    success_approve jumpi
    0x00 0x00 revert
    
    success_approve:
        // Clean stack
        pop pop pop pop                 // []
}

// Token transfer macro
#define macro TRANSFER_TOKEN() = takes (3) returns (0) {
    // Stack: [token, to, amount]
    
    0x40 mload                          // [ptr, token, to, amount]
    [TRANSFER_SELECTOR] dup2 mstore     // [ptr, token, to, amount]
    
    dup3 0x04 dup3 add mstore           // [ptr, token, to, amount]
    dup1 0x24 dup3 add mstore           // [ptr, token, to, amount]
    
    // Execute call
    0x00 0x00 0x44 dup4 0x00 dup7 gas call // [success, ptr, token, to, amount]
    
    // Check success
    success_transfer jumpi
    0x00 0x00 revert
    
    success_transfer:
        // Clean stack
        pop pop pop pop                 // []
}

// Execute swap - exact replication of Solidity assembly
#define macro EXECUTE_SWAP_EXACT() = takes (4) returns (1) {
    // Stack: [token_in, token_out, amount_in, router]
    
    0x40 mload                          // [ptr, token_in, token_out, amount_in, router]
    
    // Function selector: swapExactTokensForTokens
    [SWAP_EXACT_TOKENS_SELECTOR] dup2 mstore // [ptr, token_in, token_out, amount_in, router]
    
    // amountIn
    dup4 0x04 dup3 add mstore           // [ptr, token_in, token_out, amount_in, router]
    
    // amountOutMin = 0
    0x00 0x24 dup3 add mstore           // [ptr, token_in, token_out, amount_in, router]
    
    // path offset
    0xa0 0x44 dup3 add mstore           // [ptr, token_in, token_out, amount_in, router]
    
    // to = this
    address 0x64 dup3 add mstore        // [ptr, token_in, token_out, amount_in, router]
    
    // deadline = block.timestamp + 300
    timestamp 0x12c add 0x84 dup3 add mstore // [ptr, token_in, token_out, amount_in, router]
    
    // Path array
    0x02 0xa0 dup3 add mstore           // length = 2
    dup5 0xc0 dup3 add mstore           // token_in
    dup5 0xe0 dup3 add mstore           // token_out
    
    // Execute call and capture return data
    dup2 0x40 0x100 dup4 0x00 dup3 gas call // [success, ptr, token_in, token_out, amount_in, router]
    
    swap_success jumpi
    
    // Revert with SwapFailed()
    0x7c2f2d0100000000000000000000000000000000000000000000000000000000
    0x00 mstore
    0x04 0x00 revert
    
    swap_success:
        // Extract amountOut from return data (second element of amounts array)
        0x20 add mload                  // [amount_out, token_in, token_out, amount_in, router]
        swap4 pop pop pop pop           // [amount_out]
}

// Update gas usage statistics
#define macro UPDATE_GAS_STATS() = takes (1) returns (0) {
    // Stack: [gas_used]
    
    // Store last gas used
    dup1 [LAST_GAS_USED_SLOT] sstore   // [gas_used]
    
    // Add to total gas used
    [TOTAL_GAS_USED_SLOT] sload         // [total_gas, gas_used]
    add [TOTAL_GAS_USED_SLOT] sstore    // []
    
    // Increment execution count
    [EXECUTION_COUNT_SLOT] sload        // [count]
    0x01 add [EXECUTION_COUNT_SLOT] sstore // []
}

// Get execution statistics
#define macro GET_EXECUTION_STATS() = takes (0) returns (0) {
    // Load stats from storage
    [EXECUTION_COUNT_SLOT] sload        // [exec_count]
    dup1 0x00 eq zero_executions jumpi
    
    // Calculate average: total_gas / exec_count
    [TOTAL_GAS_USED_SLOT] sload         // [total_gas, exec_count]
    dup1 dup3 div                       // [avg_gas, total_gas, exec_count]
    
    [LAST_GAS_USED_SLOT] sload          // [last_gas, avg_gas, total_gas, exec_count]
    
    // Store return values in memory
    0x00 mstore                         // avg_gas at 0x00
    0x20 mstore                         // last_gas at 0x20
    0x40 mstore                         // total_gas at 0x40
    0x60 mstore                         // exec_count at 0x60
    
    0x80 0x00 return
    
    zero_executions:
        // All zeros
        0x00 0x00 mstore
        0x00 0x20 mstore
        0x00 0x40 mstore
        0x00 0x60 mstore
        0x80 0x00 return
}

// Check profitability (simplified view function)
#define macro CHECK_PROFITABILITY() = takes (0) returns (0) {
    // For baseline, return simplified estimates
    // In production, this would simulate swaps
    
    0x04 calldataload                   // [flash_amount]
    
    // Calculate flash fee (0.05%)
    dup1 0x05 mul 0x2710 div            // [flash_fee, flash_amount]
    
    // Simplified estimates (1:1 for baseline)
    dup2 dup2 dup2 dup2                 // [flash_fee, flash_amount, flash_fee, flash_amount, flash_fee, flash_amount]
    
    // Check if profitable (simplified)
    add dup3 gt                         // [is_profitable, flash_fee, flash_amount, ...]
    
    // Store return values
    dup3 0x00 mstore                    // expected_wpol
    dup3 0x20 mstore                    // expected_usdc_new
    dup2 0x40 mstore                    // flash_fee
    0x00 0x60 mstore                    // net_profit (simplified)
    dup1 0x80 mstore                    // is_profitable
    
    0xa0 0x00 return
}

// Withdraw function
#define macro WITHDRAW() = takes (0) returns (0) {
    ONLY_OWNER()
    
    0x04 calldataload                   // [token]
    
    // Get token balance
    0x40 mload                          // [ptr, token]
    [BALANCE_OF_SELECTOR] dup2 mstore   // [ptr, token]
    address 0x04 dup3 add mstore        // [ptr, token]
    
    0x20 dup2 0x24 dup4 0x00 dup6 gas staticcall // [success, ptr, token]
    
    balance_success jumpi
    0x00 0x00 revert
    
    balance_success:
        mload                           // [balance, token]
        dup1 0x00 eq no_balance jumpi
        
        // Transfer balance to owner
        [OWNER_SLOT] sload              // [owner, balance, token]
        dup3 dup3 dup3 TRANSFER_TOKEN() // [balance, token]
        
    no_balance:
        pop pop                         // []
        stop
}

// Get owner
#define macro GET_OWNER() = takes (0) returns (0) {
    [OWNER_SLOT] sload 0x00 mstore
    0x20 0x00 return
}