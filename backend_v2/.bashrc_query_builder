# AlphaPulse Interactive Query Builder
# Source this file: source .bashrc_query_builder
#
# Provides user-friendly query construction for complex codebase exploration

# ============================================================================
# INTERACTIVE QUERY BUILDER
# ============================================================================

# Main query builder interface
code_search() {
    local type=""
    local name=""
    local module=""
    local returns=""
    local file=""
    local visibility="any"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                type="$2"
                shift 2
                ;;
            --name)
                name="$2" 
                shift 2
                ;;
            --module)
                module="$2"
                shift 2
                ;;
            --returns)
                returns="$2"
                shift 2
                ;;
            --file)
                file="$2"
                shift 2
                ;;
            --visibility)
                visibility="$2"
                shift 2
                ;;
            --help)
                code_search_help
                return 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                code_search_help
                return 1
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$type" && -z "$name" && -z "$module" ]]; then
        echo "Error: At least one filter is required (--type, --name, or --module)" >&2
        code_search_help
        return 1
    fi
    
    # Build and execute query
    _execute_code_search "$type" "$name" "$module" "$returns" "$file" "$visibility"
}

# Execute the actual search
_execute_code_search() {
    local type="$1"
    local name="$2" 
    local module="$3"
    local returns="$4"
    local file="$5"
    local visibility="$6"
    
    # Ensure JSON is available
    local json_file="protocol_v2/target/doc/protocol_v2.json"
    if [[ ! -f "$json_file" ]]; then
        echo "📦 Generating documentation..."
        (cd protocol_v2 && cargo +nightly rustdoc --lib -- --output-format json -Z unstable-options 2>/dev/null)
    fi
    
    echo "🔍 Code Search Results"
    echo "====================="
    [[ -n "$type" ]] && echo "  Type filter: $type"
    [[ -n "$name" ]] && echo "  Name filter: $name"
    [[ -n "$module" ]] && echo "  Module filter: $module"
    [[ -n "$returns" ]] && echo "  Returns filter: $returns"
    [[ -n "$file" ]] && echo "  File filter: $file"
    [[ "$visibility" != "any" ]] && echo "  Visibility: $visibility"
    echo ""
    
    # Build jq filter  
    local jq_filter='.index | to_entries[] | select('
    local conditions=()
    
    # Always filter out null names
    conditions+=('.value.name != null')
    
    # Type filter
    if [[ -n "$type" ]]; then
        case "$type" in
            struct)
                conditions+=('.value.inner.struct')
                ;;
            enum)
                conditions+=('.value.inner.enum')
                ;;
            function)
                conditions+=('.value.inner.function')
                ;;
            trait)
                conditions+=('.value.inner.trait')
                ;;
            module)
                conditions+=('.value.inner.module')
                ;;
            impl)
                conditions+=('.value.inner.impl')
                ;;
            *)
                conditions+=(".value.inner.${type}")
                ;;
        esac
    fi
    
    # Name filter
    if [[ -n "$name" ]]; then
        conditions+=(".value.name != null and (.value.name | test(\"$name\"; \"i\"))")
    fi
    
    # Visibility filter
    if [[ "$visibility" == "public" ]]; then
        conditions+=('.value.visibility == "public"')
    elif [[ "$visibility" == "private" ]]; then
        conditions+=('.value.visibility != "public"')
    fi
    
    # File filter
    if [[ -n "$file" ]]; then
        conditions+=(".value.span.filename | test(\"$file\")")
    fi
    
    # Join conditions with 'and'
    local filter_expr=""
    if [[ ${#conditions[@]} -gt 0 ]]; then
        filter_expr=$(IFS=' and '; echo "${conditions[*]}")
    else
        filter_expr="true"
    fi
    
    jq_filter="${jq_filter}${filter_expr}) | {
        type: (.value.inner | keys[0]),
        name: .value.name,
        file: .value.span.filename,
        visibility: .value.visibility
    }"
    
    # Execute query and format results
    jq -r "[$jq_filter] | sort_by(.name)[] | \"\\(.type): \\(.name) (\\(.file | split(\"/\")[-1]))\"" \
        "$json_file" 2>/dev/null || echo "❌ Query failed"
}

# Architecture mapping with query builder
architecture_map() {
    local service=""
    local show_deps=false
    local show_interfaces=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --service)
                service="$2"
                shift 2
                ;;
            --show)
                case "$2" in
                    dependencies|deps)
                        show_deps=true
                        ;;
                    interfaces)
                        show_interfaces=true
                        ;;
                    *)
                        echo "Unknown --show option: $2" >&2
                        return 1
                        ;;
                esac
                shift 2
                ;;
            --help)
                architecture_map_help
                return 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                architecture_map_help  
                return 1
                ;;
        esac
    done
    
    echo "🏗️  Architecture Map"
    echo "==================="
    
    if [[ -n "$service" ]]; then
        echo "🎯 Focus: $service service"
        echo ""
        
        case "$service" in
            adapters)
                echo "📊 Adapter Service Architecture:"
                code_search --type struct --name ".*Adapter.*|.*Collector.*"
                echo ""
                echo "🔗 Key Traits:"
                code_search --type trait --module "adapter"
                ;;
            protocol)
                echo "📊 Protocol V2 Architecture:" 
                echo "  🏗️ TLV Message Types:"
                code_search --type struct --name ".*TLV$"
                echo ""
                echo "  🎯 Core Enums:"
                code_search --type enum --name "TLVType|RelayDomain|InstrumentId"
                ;;
            strategies)
                echo "📊 Strategy Architecture:"
                code_search --name ".*Strategy.*"
                ;;
            *)
                echo "❓ Unknown service: $service"
                echo "Available: adapters, protocol, strategies"
                return 1
                ;;
        esac
    else
        # Show general architecture
        echo "🏗️  General Architecture:"
        echo ""
        echo "📦 Core Components:"
        code_search --type struct --name ".*TLV$|.*Builder.*|.*Manager.*" | head -10
        echo ""
        echo "🎯 Key Traits (Interfaces):"
        code_search --type trait | head -5
    fi
    
    if [[ "$show_deps" == "true" ]]; then
        echo ""
        echo "🔗 Dependencies:"
        show_dependencies | head -10
    fi
    
    if [[ "$show_interfaces" == "true" ]]; then
        echo ""
        echo "🔌 Public Interfaces:"
        code_search --type function --visibility public | head -8
    fi
}

# ============================================================================
# SPECIALIZED QUERY BUILDERS
# ============================================================================

# Find similar implementations with context
find_implementations() {
    local pattern="$1"
    local context="${2:-}"
    
    if [[ -z "$pattern" ]]; then
        echo "Usage: find_implementations <pattern> [context]" >&2
        echo "Examples:"
        echo "  find_implementations 'parse' address"
        echo "  find_implementations 'validate' tlv" >&2
        return 1
    fi
    
    echo "🔍 Implementations of '$pattern'"
    [[ -n "$context" ]] && echo "    Context: $context"
    echo "================================"
    
    # Find functions
    echo "📋 Functions:"
    code_search --type function --name ".*${pattern}.*" | head -10
    
    # Find structs/types  
    echo ""
    echo "📋 Types:"
    code_search --type struct --name ".*${pattern}.*" | head -5
    code_search --type enum --name ".*${pattern}.*" | head -5
    
    # Context-specific search
    if [[ -n "$context" ]]; then
        echo ""
        echo "📋 Context-specific ($context):"
        code_search --name ".*${context}.*${pattern}.*|.*${pattern}.*${context}.*" | head -5
    fi
    
    echo ""
    echo "💡 Before implementing '$pattern':"
    echo "   - Review existing similar functions above"
    echo "   - Consider extending vs. creating new"
    echo "   - Check if a trait abstraction is needed"
}

# Trace data flow and message types
trace_data_flow() {
    local message_type="$1"
    
    if [[ -z "$message_type" ]]; then
        echo "Usage: trace_data_flow <message_type>" >&2
        echo "Examples:"
        echo "  trace_data_flow 'PoolSwap'"
        echo "  trace_data_flow 'Trade'" >&2
        return 1
    fi
    
    echo "🔄 Data Flow Trace: '$message_type'"
    echo "================================="
    
    # Find the message type definition
    echo "📦 Message Definition:"
    code_search --type struct --name ".*${message_type}.*TLV$" | head -3
    
    # Find builders
    echo ""
    echo "🏗️ Builders/Constructors:" 
    code_search --name ".*${message_type}.*Builder|build_${message_type}" | head -5
    
    # Find consumers (functions that take this type)
    echo ""
    echo "📥 Consumers:" 
    code_search --type function --name ".*${message_type}.*|.*process.*|.*handle.*" | head -5
    
    # Find related validation
    echo ""
    echo "✅ Validation:"
    code_search --name ".*validate.*${message_type}.*|.*${message_type}.*valid.*" | head -3
    
    echo ""
    echo "🔄 Typical Flow:"
    echo "   External Data → Adapter → ${message_type}TLV → Relay → Strategy"
}

# ============================================================================
# HELP SYSTEMS
# ============================================================================

# Help for code_search
code_search_help() {
    echo "Code Search Query Builder"
    echo "========================="
    echo ""
    echo "Usage: code_search [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  --type TYPE         Filter by item type (struct, enum, function, trait, module, impl)"
    echo "  --name PATTERN      Filter by name pattern (supports regex)"
    echo "  --module MODULE     Filter by module name"
    echo "  --returns TYPE      Filter functions by return type pattern"
    echo "  --file FILE         Filter by filename pattern" 
    echo "  --visibility VIS    Filter by visibility (public, private, any)"
    echo "  --help              Show this help"
    echo ""
    echo "Examples:"
    echo "  code_search --type struct --name 'Pool.*'"
    echo "  code_search --type function --name 'parse.*' --visibility public"
    echo "  code_search --module tlv --type enum"
    echo "  code_search --name 'TLV$' --type struct"
    echo ""
    echo "Combine multiple filters for precise results!"
}

# Help for architecture_map
architecture_map_help() {
    echo "Architecture Mapping Tool"
    echo "========================"
    echo ""
    echo "Usage: architecture_map [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  --service SERVICE   Focus on specific service (adapters, protocol, strategies)"
    echo "  --show WHAT         Show additional info (dependencies, interfaces)"
    echo "  --help              Show this help"
    echo ""
    echo "Examples:" 
    echo "  architecture_map                              # General overview"
    echo "  architecture_map --service adapters           # Focus on adapters"
    echo "  architecture_map --service protocol --show interfaces  # Protocol with APIs"
    echo "  architecture_map --show dependencies          # Include dependency info"
}

# Main help for query builder
query_builder_help() {
    echo "AlphaPulse Interactive Query Builder"
    echo "===================================="
    echo ""
    echo "PRIMARY TOOLS:"
    echo "  code_search [options]           - Flexible code search with filters"
    echo "  architecture_map [options]      - Service architecture mapping"
    echo ""
    echo "SPECIALIZED QUERIES:"
    echo "  find_implementations <pattern>  - Find existing implementations"
    echo "  trace_data_flow <message_type>  - Trace message flow through system"
    echo ""
    echo "HELP:"
    echo "  code_search --help             - Code search options"
    echo "  architecture_map --help        - Architecture mapping options"
    echo ""
    echo "QUICK EXAMPLES:"
    echo "  code_search --type struct --name 'Pool.*'     # All Pool structs"
    echo "  architecture_map --service adapters           # Adapter architecture"
    echo "  find_implementations 'validate'               # Validation patterns"
    echo "  trace_data_flow 'Trade'                       # Trade message flow"
    echo ""
    echo "💡 Use these tools to explore before writing new code!"
}