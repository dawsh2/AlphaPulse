//! Integration test: Flash Arbitrage consuming TLV messages from Polygon
//!
//! Tests that the flash arbitrage strategy can correctly consume and process
//! TLV messages generated by the Polygon DEX collector.

use tokio::sync::mpsc;
use tracing_subscriber;

use alphapulse_protocol::{
    TLVMessage, MessageHeader, RelayDomain,
    tlv::market_data::PoolSwapTLV,
};

/// Test core TLV message processing pipeline
#[tokio::test]
async fn test_polygon_tlv_message_creation() {
    println!("ðŸ§ª Testing Polygon TLV Message Creation");
    
    // Create a realistic Polygon swap TLV message
    let swap_tlv = create_polygon_swap_tlv();
    let tlv_message = swap_tlv.to_tlv_message();
    
    println!("âœ… Created Polygon swap TLV: {} bytes", tlv_message.payload.len());
    
    // Verify TLV message structure
    assert!(tlv_message.payload.len() > 0, "TLV payload should not be empty");
    
    // Create relay message header (matching live_polygon_relay.rs format)
    let header = MessageHeader {
        magic: 0xDEADBEEF,
        relay_domain: RelayDomain::MarketData as u8,
        version: 1,
        source: 3, // Polygon source ID
        flags: 0,
        payload_size: tlv_message.payload.len() as u32,
        sequence: 1,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64,
        checksum: 0, // Performance mode
    };
    
    // Serialize complete relay message
    let header_bytes = unsafe {
        std::slice::from_raw_parts(
            &header as *const MessageHeader as *const u8,
            std::mem::size_of::<MessageHeader>()
        )
    };
    
    let mut relay_message = Vec::with_capacity(header_bytes.len() + tlv_message.payload.len());
    relay_message.extend_from_slice(header_bytes);
    relay_message.extend_from_slice(&tlv_message.payload);
    
    println!("âœ… Created relay message: {} bytes total", relay_message.len());
    
    // Verify relay message structure
    assert_eq!(relay_message.len(), 32 + tlv_message.payload.len(), "Relay message should be header + payload");
    
    // Test header parsing
    let parsed_magic = u32::from_le_bytes([relay_message[0], relay_message[1], relay_message[2], relay_message[3]]);
    assert_eq!(parsed_magic, 0xDEADBEEF, "Magic number should be correctly parsed");
    
    let parsed_payload_size = u32::from_le_bytes([relay_message[8], relay_message[9], relay_message[10], relay_message[11]]);
    assert_eq!(parsed_payload_size as usize, tlv_message.payload.len(), "Payload size should match");
    
    println!("âœ… Complete message structure validation passed: Polygon â†’ Relay Message");
}

/// Test TLV message serialization compatibility between components
#[tokio::test]
async fn test_tlv_compatibility_polygon_flash_arbitrage() {
    println!("ðŸ§ª Testing TLV Compatibility: Polygon â†” Flash Arbitrage");
    
    // Create TLV using Polygon DEX style
    let polygon_swap = create_polygon_swap_tlv();
    let polygon_bytes = polygon_swap.to_bytes().expect("TLV serialization should work");
    
    println!("âœ… Polygon TLV serialized: {} bytes", polygon_bytes.len());
    
    // Parse using Flash Arbitrage consumer logic
    let parsed_swap = PoolSwapTLV::from_bytes(&polygon_bytes)
        .expect("Flash arbitrage should parse Polygon TLV");
    
    println!("âœ… Flash arbitrage parsed TLV successfully");
    
    // Verify data integrity
    assert_eq!(polygon_swap.pool_address, parsed_swap.pool_address, "Pool address must match");
    assert_eq!(polygon_swap.amount_in, parsed_swap.amount_in, "Amount in must match");
    assert_eq!(polygon_swap.amount_out, parsed_swap.amount_out, "Amount out must match");
    assert_eq!(polygon_swap.amount_in_decimals, parsed_swap.amount_in_decimals, "Input decimals must match");
    assert_eq!(polygon_swap.amount_out_decimals, parsed_swap.amount_out_decimals, "Output decimals must match");
    
    println!("âœ… TLV data integrity verified across components");
    
    // Test that both preserve native precision
    assert!(polygon_swap.amount_in > 0, "Amount in should be positive");
    assert!(polygon_swap.amount_out > 0, "Amount out should be positive");
    assert_eq!(polygon_swap.amount_in_decimals, 18, "WETH should have 18 decimals");
    assert_eq!(polygon_swap.amount_out_decimals, 6, "USDC should have 6 decimals");
    
    println!("âœ… Native precision preservation verified");
}

/// Test TLV header and basic message structure parsing
#[tokio::test]
async fn test_relay_header_parsing() {
    println!("ðŸ§ª Testing Relay Header Parsing Logic");
    
    // Create minimal valid relay message
    let header = MessageHeader {
        magic: 0xDEADBEEF,
        relay_domain: RelayDomain::MarketData as u8,
        version: 1,
        source: 3,
        flags: 0,
        payload_size: 4, // Just 4 bytes of dummy TLV
        sequence: 123,
        timestamp: 1692715200000000000, // Fixed timestamp
        checksum: 0,
    };
    
    let header_bytes = unsafe {
        std::slice::from_raw_parts(
            &header as *const MessageHeader as *const u8,
            std::mem::size_of::<MessageHeader>()
        )
    };
    
    // Add minimal TLV payload
    let mut message = header_bytes.to_vec();
    message.extend_from_slice(&[11u8, 0u8, 2u8, 0u8]); // Type 11 (PoolSwap), Flags 0, Length 2, dummy data
    
    // Test header parsing logic directly
    assert!(message.len() >= 32, "Message should have valid header size");
    
    let parsed_magic = u32::from_le_bytes([message[0], message[1], message[2], message[3]]);
    assert_eq!(parsed_magic, 0xDEADBEEF, "Should parse valid magic number");
    
    let parsed_payload_size = u32::from_le_bytes([message[8], message[9], message[10], message[11]]);
    assert_eq!(parsed_payload_size, 4, "Should parse correct payload size");
    
    // Test invalid magic number handling
    let mut bad_message = message.clone();
    bad_message[0..4].copy_from_slice(&0x12345678u32.to_le_bytes());
    
    let bad_magic = u32::from_le_bytes([bad_message[0], bad_message[1], bad_message[2], bad_message[3]]);
    assert_ne!(bad_magic, 0xDEADBEEF, "Should detect invalid magic number");
    
    println!("âœ… Relay header parsing logic verification complete");
}

/// Create a realistic Polygon swap TLV for testing
fn create_polygon_swap_tlv() -> PoolSwapTLV {
    use alphapulse_protocol::VenueId;
    
    PoolSwapTLV {
        venue: VenueId::Polygon,
        pool_address: [0x45, 0xdd, 0xa9, 0xcb, 0x7c, 0x25, 0x13, 0x1d, 0xf2, 0x68, 0x51, 0x51, 0x31, 0xf6, 0x47, 0xd7, 0x26, 0xf5, 0x06, 0x08], // WETH/USDC pool
        token_in_addr: [0x7c, 0xeb, 0x23, 0xfd, 0x6f, 0x88, 0xb7, 0x6a, 0xf0, 0x52, 0xc3, 0xca, 0x45, 0x9c, 0x11, 0x73, 0xc5, 0xb9, 0xb9, 0x6d], // WETH
        token_out_addr: [0x27, 0x91, 0xbc, 0xa1, 0xf2, 0xde, 0x46, 0x61, 0xed, 0x88, 0xa3, 0x0c, 0x99, 0xa7, 0xa9, 0x44, 0x9a, 0xa8, 0x41, 0x74], // USDC
        amount_in: 5_000_000_000_000_000_000u128, // 5 WETH (18 decimals)
        amount_out: 13500_000_000u128, // 13,500 USDC (6 decimals)
        amount_in_decimals: 18,
        amount_out_decimals: 6,
        sqrt_price_x96_after: PoolSwapTLV::sqrt_price_from_u128(1792282187229267636352u128), // Realistic V3 price
        tick_after: 3393,
        liquidity_after: 500000000000000000u128,
        timestamp_ns: std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as u64,
        block_number: 48_650_000,
    }
}